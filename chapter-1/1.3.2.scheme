1.3.2 lambdaを用いた手続きの構築

(lambda (x) (+ x 4))

(lambda (x) (/ 1.0 (* x (+ x 2))))

pi-sum手続きは補助的な手続きを定義することなしに表現が可能になる。

(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))

一般的に、lambdaはdefineと同様に手続きを作成するが、
手続きに対しても名前が指定されないことが異なる。

(lambda (<formal-parameters>) <body>)

結果としての手続きはdefineを用いて作成した手続きと同じ。
ただひとつの違いはそれが環境においてどのような名前にも結び付けられていないこと。

(deifne (plus4 (+ x 4)))

(define plus4 (lambda (x) (+ x 4)))


(lambda      (x)      (+   x   4)      )
手続きは  引数を持ち  足す xと 4


任意の値として手続きを持つ式と同様に、lambda式は複合式においてオペレータとして使用することが可能。

((lambda (x y zz) (+x y (square z))))

またはより一般的に、私達が通常手続きの名前を使用する任意の文脈において使用可能。



ローカル変数仕様のためのletを用いる
別のlambda使用法にはローカル変数の作成がある。
形式的パラメータに束縛されていないローカル変数を手続きで必要とする場合はよくある。


中間値の名前としてローカル変数として含みたくなる場合がある。
これを実現する1つの方法として補助的な手続きをローカル変数を束縛するため使用することがある。

(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))

もちろん、lambda式を用いて無名手続きをローカル変数の束縛のために指定することも可能。

(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))


この構成はとても便利でletと呼ばれる特殊形式がその使用をより便利にするために用意されている。

(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))


let <var1> have the value <exp1> and
    <var2> have the value <exp2>
in <body>

letは使役の意味なので、<body>の中では<var1>は<exp1>の値を持たせる、と読める。
let式の最初の部分は名前と式のペアのリスト。
letが評価される時、各名前は関連する式の値と関連付けされる。
letのボディはこれらのローカルな値に束縛された名前とともに評価される。
let式は以下のだいたい文法として評価されるためにこれが起こる

((lambda (<var1> ... <varn>)
  <body>)
  <exp1>
  <expn>)

インタプリタ内にはローカル変数を提供するために新しいメカニズムが必要とされない。
let式は中で行われるlambda適用に対する構文糖でしかない。

この等価式から、let式にて指定された変数のスコープがletのボディであることがわかる。

letは変数を可能な限り仕様される場所に局所的に束縛する。
xの値が5であるとき、次の式の値は38

(+ (let ((x 3))
     (+ x (* x 10)))
   x)

ここでletのボディの中のxは3なので、let式の値は33
最も外側の+の第二引数であるxは依然5

変数の値はletの外側にて計算される。
これはローカル変数の値を提供する式がローカル変数自身と同じ名前を持っている変数に依存する場合に問題となる。


(let ((x 3)
      (y (+ x 2)))
  (* x y))

時にはletと同様の効果を得るために内部定義を利用することもある。

(define (f x y)
  (define a (+ 1 (* x y)))
  (define b (- 1 y))
  (+ (* x (square a))
     (* y b)
     (* a b)))


しかしこのような状況ではletを使用し、内部定義は内部手続のみのために利用することを好む。

