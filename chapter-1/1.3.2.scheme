1.3.2 lambdaを用いた手続きの構築

(lambda (x) (+ x 4))

(lambda (x) (/ 1.0 (* x (+ x 2))))

pi-sum手続きは補助的な手続きを定義することなしに表現が可能になる。

(define (pi-sum a b)
  (sum (lambda (x) (/ 1.0 (* x (+ x 2))))
       a
       (lambda (x) (+ x 4))
       b))

一般的に、lambdaはdefineと同様に手続きを作成するが、
手続きに対しても名前が指定されないことが異なる。

(lambda (<formal-parameters>) <body>)

結果としての手続きはdefineを用いて作成した手続きと同じ。
ただひとつの違いはそれが環境においてどのような名前にも結び付けられていないこと。

(deifne (plus4 (+ x 4)))

(define plus4 (lambda (x) (+ x 4)))


(lambda      (x)      (+   x   4)      )
手続きは  引数を持ち  足す xと 4


任意の値として手続きを持つ式と同様に、lambda式は複合式においてオペレータとして使用することが可能。

((lambda (x y zz) (+x y (square z))))

またはより一般的に、私達が通常手続きの名前を使用する任意の文脈において使用可能。



ローカル変数仕様のためのletを用いる
別のlambda使用法にはローカル変数の作成がある。
形式的パラメータに束縛されていないローカル変数を手続きで必要とする場合はよくある。


中間値の名前としてローカル変数として含みたくなる場合がある。
これを実現する1つの方法として補助的な手続きをローカル変数を束縛するため使用することがある。

(define (f x y)
  (define (f-helper a b)
    (+ (* x (square a))
       (* y b)
       (* a b)))
  (f-helper (+ 1 (* x y))
            (- 1 y)))

もちろん、lambda式を用いて無名手続きをローカル変数の束縛のために指定することも可能。

(define (f x y)
  ((lambda (a b)
     (+ (* x (square a))
        (* y b)
        (* a b)))
   (+ 1 (* x y))
   (- 1 y)))


この構成はとても便利でletと呼ばれる特殊形式がその使用をより便利にするために用意されている。

(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
