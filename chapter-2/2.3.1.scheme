2.3.1 クォート

もし記号を用いて複合データを形成できれば以下のようなリストを持つことができます。

(a b c d)

(23 45 17)

((Norah 12) (Molly 9) (Anna 7))

記号を含むリストは言語の式と全く同じように見えます。

(* (+ 23 45)
   (+ x 9))

(define (fact n)
  (if (= n 1) 1 (* n (fact (- n 1)))))

記号を扱う目的のためには言語に新しい要素を必要とします。
データオブジェクトをquoteする能力です。
新しいリスト(a b)を構築したいとします。
私たちはこれを(list a b)を用いては達成できません。
なぜならこの式はaとbの値からリストを構築する式であり、記号それ自体ではないからです。
この問題は自然言語の文脈ではよく知られていて、単語と分が意味上の要素としてみなされているか、または文字列(文法上の要素)としてみなされているかの場合があり得ます。
自然言語での共通な慣例は単語や分が文字通りに扱われることを示すためにクォーテーションマークをつけること。

データオブジェクトとして扱われるべきであり、式として評価されるべきではないリストとシンボルを区別するために、
これと同じ週間に従うことが出来ます。しかしクォートする形式は自然言語のそれとは異なり、クォーテーションマーク(伝統的にシングルクォートの記号')はクォートされるべきオブジェクトの先頭にのみ置かれる。
Schemeの文法でこのように逃れられるのはオブジェクトを区切るのに空白とカッコを信頼できるから。
従ってシングルクォートの意味は次のオブジェクトをクォートすることになる。

(define a 1)
(define b 2)
(list a b)   ; (1 2)
(list 'a 'b) ; (a b)
(list 'a b)  ; (a 2)


クォーテーションはまた慣習的なリストに対する印字された表現を用いて複合オブジェクトの入力も可能にする。

(car '(a b c))
a

(cdr '(a b c))
(b c)

これを守ることで、空リストを'()を評価して得ることができる。従って、変数nilの使用をやめられる。

記号を操作するのに使われるもう1つの追加のプリミティブとしてeq?がある。
これは2つのシンボルを引数として取り、それらが同じであるかテストする。
eq?を用いることでmemqと呼ばれる便利な手続きを実装できる。
これは2つの引数、シンボルとリストを取ります。もしシンボルがリストに含まれていない場合、false
そうでなければリストの中のそのシンボルが最初に出現する場所からのサブリストを返す。

(define (memq item x)
  (cond ((null? x) false)
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))

(memq 'apple '(pear banana prune)) ; false

(memq 'apple '(x (apple sauce) y apple pear)) ; (apple pear)

