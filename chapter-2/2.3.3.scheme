2.3.3 例: 集合を表現する

集合は異なる要素の単純な集まり。
より正確な定義を与えるために私たちはデータ抽象の手法を用いることが出来る。
それは集合を集合上で用いられる操作を特定することで定義すること。
これらは
union-set
intersection-set
element-of-set?
adjoin-set

element-of-set?
与えられた要素が集合のメンバーであるかを判定する述語

adjoin-set
オブジェクトと集合を引数として取り、元の集合の要素と挿入された要素も含む集合を返す。

union-set
どちらかの引数に表れるすべての要素を含む集合である、2つの集合の和集合を計算する

intersection-set
両方の引数の中に表れる要素のみを含む、2つの集合の共通集合を計算する。

データ抽象の始点から見ると、私たちは上で与えられた解釈と一致する方法であれば、
これらの命令を実装するどんな表現を設計することも自由。


順序なしリストとしての集合
集合を表現するための1つの方法は、どの要素も一度より多くは現れない要素のリストとする。
空集合は空リストとして表現される。
この表現ではelement-of-set?はmemqと似ている。
eq?の代わりにequal?を用いているので集合要素はシンボルである必要はない。

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

これを用いてadjoin-setを×。
adjoinされるオブジェクトが既に集合に存在する場合、単に元の集合を返す。
そうでなければconsを用いてオブジェクトを集合を表すリストに追加する。

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

intersection-setに対して再帰の戦略を使用できる。
もしset2とset1のcdrの共通集合の求める方法がわかれば、これにset1のcarを含めるかどうか決定することのみが必要。

しかしこれは(car set1)がset2にも存在するかに依存する。

(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1)
               (intersection-set (cdr set1) set2))
         (else (intersection-set (cdr set1) set2)))))

表現の設計において、私達が考慮しなければならない問題の1つは効率。
集合操作により必要とされるステップ数を考えてください。
それら全てがelement-of-set?を使用するので、この命令のスピードは総じて集合実装の効率上に主要な影響を与える。
おっこで、あるオブジェクトが集合の要素であるかをチェックするために、element-of-set?は集合全体をスキャンしなければならないかもしれない。
それ故にもしその集合がn要素を持つ場合、element-of-set?は最大nステップかかるかもしれない。
従って必要とされるステップ数は、θ(n)で増加する。
adjoin-setにより必要とされるステップ数は、それがこの命令を用いるので、これもまたθ(n)で増加する。
intersection-setは、set1の各要素に対しelement-of-set?のチェックを行うため、必要とされるステップ数は
関係する集合のサイズの積か、またはサイズnの2つの集合に対しθ(n^2)で増加する。
union-setに対しても同じことが言える。


順序有りリストとしての集合

私達の集合操作を高速化するための1つの方法として表現を変更することで集合要素を昇順に並べる方法があります。
これを行うには2つのオブジェクトを比較する何らかの方法が必要。
それによりどちらが大きいを言うことができる。
例えばシンボルを辞書順で比較したり、オブジェクトに一位の番号を付け、その後要素を対応する番号で比較するための何らかの方法について同意できる。
数値の集合をその要素を昇順に並べることで表現する。

順序付けの1つの利点はelement-of-set?にて表れる。
項目の存在をチェックする場合において、集合全体をスキャンする必要はない。
もし探している項目よりも大きな要素に出会ったならばその集合にこの項目が無いことがわかる。

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) true)
        (else (element-of-set? x (cdr set)))))


これがどれだけのステップを割り引くでしょうか？最悪の場合、探している項目は集合の中で一番大きいものかもしれません。
その場合ステップ数は順序なし表現と同じ。
しかし一方でもし多くの異なるサイズの項目を探している場合、時々はリストの先頭近くの天で検索を停止することができることを期待できる。
そして他の場合にはやはりリストのほとんどを試験しなければいけない。

平均では集合の項目数の半分近くを試験しなければならないことが期待できるはず。
従って必要とされる平均のステップ数は約n/2となる。
これはそれでもθ(n)で増加するが、以前の実装に対して平均的にはステップ数において半分で節約する。

intersection-setではより目覚ましい高速化を得る。
順序なし表現ではこの命令はθ(n^2)ステップを必要とした。
set1の各要素に対しtset2の完全なスキャンを実行していたため。
しかし順序有り表現ではより賢い方法を用いることもできる。
2つの集合の最初の要素x1とx2を比較することではじめ、もしx1とx2が等しい場合にはそれらは共通集合の要素。
そして共通集合の残りは2つの集合のcdrの共通集合。そうでなくx1がx2より小さい場合を考える。
x2はset2の最小の要素ですからすぐにx1はset2のどこにも現れず、従って共通集合にはあり得ない。
従って共通集合はset2とset1のcdrの共通集合に等しいとなる。
同様にもしx2がx1より小さい場合、共通集合はset1とset2のcdrの共通集合にて与えられる。

(define (intersection-set set1 set2)
  (if (or (null? set1)) (x (null? set2))
      '()
      (let ((x1 (car set1))
            (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1 (intersection-set (cdr set1)
                                          (cdr st2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))

必要とされるステップ数は最大でもset1とset2のサイズの合計。
θ(n^2)ではなくθ(n)で増加するため、例え中程度のサイズの集合に対してでも考慮に値する高速化。


二分木としての集合

集合要素を木の形式にて準備することで順序有りリスト表現よりも良く行うことができる。
木の各ノードはそのノードにおけるエントリと呼ばれる集合の1つの要素と他の2つの(空にもあり得る)ノードへのリンクを持つ。

左のリンクはそのノードよりも小さな値を示し、右のリンクはそのノードの値より大きなノードを指す。

木表現の優位点は以下のとおりです。
ある数値xがある集合に含まれているかどうかをチェックしたいと想定。
xをトップノードのエントリと比較する。
もしxがこれよりも小さければ、左の部分木のみを探索。
xが大きければ、右の部分木のみを探索。
ここで、木がバランスが取れた状態であるとは各部分木のサイズが元の約半分であるということ。
従って一度のステップにおいてサイズnの木の探索問題を、サイズn/2の木の探索問題に縮小したことになる。
各ステップにより木の探索に必要なステップは半分になるのでサイズnの木の探索に必要なステップ数はθ(logn)で増加することが期待される。
大きな集合に対しては以前の表現に比べこれは著しい高速化になる。
木はリストを用いて表現できる。
各ノードは3つの項目のリストになる。
ノードのエントリ、左部分木、右部分木。
左、または右部分木が空リストの場合はそこに接続された部分木が存在しないことを示す。

(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))

これでelement-of-set?手続きを上で説明された戦略を用いて書くことが出来る。

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))

集合に項目を付加することは同様に実装され、そしてまたθ(logn)ステップを必要とする。
項目xを付加するためには、xをノードのエントリと比較しxが右か左のどちらの枝に追加されるべきを判断し、
xを適切な枝に追加し、この新しく構築された枝を元のエントリともう一方の枝とともに接続する。
もしxを空の木に不可するよう求められたらエントリにxをもち、右と左の枝は空である木を生成する。














