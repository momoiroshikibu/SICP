2.3.4 例: ハフマン符号化木

1と」0のビットの列としてのデータを表現するための手法。
ハフマン符号は葉が符号化された記号である二分木として表現することができる。
木の葉でないノードのそれぞれにはそのノードの下に位置する葉の中のシンボル全てを含む集合があります。
加えて各葉のシンボルには主に(相対的な頻度)が割り振られており、葉でないノードのそれぞれはその下に位置する葉の重み全ての合計である重みを持っている。
重みはエンコード、デコード処理では利用されない。

ハフマン木を与えられることで、任意のシンボルの富豪を木の根からはじめてそのシンボルを持つ葉にたどり着くまで降りていくことで見つけることができる。
左の枝に降りる度に富豪に0を追加し、右の枝に降りる度に1を追加する。

ビット列をハフマン木を用いて復号するには、根からはじめてビット列の一連の0と1を用いて左か右の枝を降りるのか決定する。
葉に着く度に、メッセージの新しいシンボルを生成し、その時点で木の根から西海市次のシンボルを見つける。


ハフマン木の生成
木を再配置することで最も低い頻度のシンボルが根からもっとも遠く表れるようにする。
シンボルと頻度を含む葉のノードの集合と共に符号が構築される初期データにより決定されるに従うまず重みが最低の2つの葉を見つけ、それらをマージしてこの2つのノードを左と右の枝に持つノードを生成する。
新しいノードの重みは2つの重みの和。
この処理を続ける。
各ステップにて最も小さな重みを持つ2つのノードをマージし、集合から削除し、これらの2つを左と右の枝に持つノードで置き換える。
処理は1つのノードのみが残った時に停止し、それが木全体の根になる。

このアルゴリズムは常に同じ木を特定しない。
各ステップにおいて重みが最小のペアが一位とは限らないため。
またどの2つのノードがマージされるのかの順序も決定しない。
(つまり、どれが右になり、どれが左になるかはわからない)


ハフマン木の表現
ハフマン木を用いてメッセージの符号化・復号化を行い、かつ上で概説したアルゴリズムにもとづきハフマン木を作成します。
気はどのように表現されるかの議論から始める。

この母シンボルleaf、葉に対するシンボル、そして重みから構成されるリストにて表現される。

(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))

(define (weight-leaf x) (caddr x))

一般的な木は左側の枝、右側の枝、シンボルの集合、そして重みのリストになる。
シンボルの集合は単純にシンボルのリストとなり、より洗練された集合の表現を用いない。
2つのノードをマージして木を作る時、木の重みを各ノードの重みの和として取得し、シンボルの集合は各ノードのシンボルの集合の和集合とする。
シンボルの集合はリストとして表現されているので和集合はappend手続きを用いて形成することができる。

(define (make-code-tree left right)
  (list left right (append (symbols left)
                           (symnbols right))
        (+ (weight left)
           (weight right))))

もしこのように木を作るのなら、以下のようなセレクタを持つことになる。

(define (left-branch tree) (car tree))

(define (right-branch tree) (cadr tree))

(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (caddr tree)))


手続きsymbolsとweightはそれらが葉と一般的な木のどちらと共に呼ばれたかにより少々異なったことをしなければならない。
これらはgeneric procedures(ジェネリック手続き: に種類以上のデータを扱える手続き)の簡単なサンプル。

