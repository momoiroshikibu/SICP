2.3.4 例: ハフマン符号化木

1と」0のビットの列としてのデータを表現するための手法。
ハフマン符号は葉が符号化された記号である二分木として表現することができる。
木の葉でないノードのそれぞれにはそのノードの下に位置する葉の中のシンボル全てを含む集合があります。
加えて各葉のシンボルには主に(相対的な頻度)が割り振られており、葉でないノードのそれぞれはその下に位置する葉の重み全ての合計である重みを持っている。
重みはエンコード、デコード処理では利用されない。

ハフマン木を与えられることで、任意のシンボルの富豪を木の根からはじめてそのシンボルを持つ葉にたどり着くまで降りていくことで見つけることができる。
左の枝に降りる度に富豪に0を追加し、右の枝に降りる度に1を追加する。

ビット列をハフマン木を用いて復号するには、根からはじめてビット列の一連の0と1を用いて左か右の枝を降りるのか決定する。
葉に着く度に、メッセージの新しいシンボルを生成し、その時点で木の根から西海市次のシンボルを見つける。


ハフマン木の生成
木を再配置することで最も低い頻度のシンボルが根からもっとも遠く表れるようにする。
シンボルと頻度を含む葉のノードの集合と共に符号が構築される初期データにより決定されるに従うまず重みが最低の2つの葉を見つけ、それらをマージしてこの2つのノードを左と右の枝に持つノードを生成する。
新しいノードの重みは2つの重みの和。
この処理を続ける。
各ステップにて最も小さな重みを持つ2つのノードをマージし、集合から削除し、これらの2つを左と右の枝に持つノードで置き換える。
処理は1つのノードのみが残った時に停止し、それが木全体の根になる。

このアルゴリズムは常に同じ木を特定しない。
各ステップにおいて重みが最小のペアが一位とは限らないため。
またどの2つのノードがマージされるのかの順序も決定しない。
(つまり、どれが右になり、どれが左になるかはわからない)

