2.4.3 データ的銃プログラミングと付加性

データの方をチェックし適切な手続きを呼ぶ一般的な戦略はdispatching on type (タイプ別処理)と呼ばれる。
これはシステム設計にお家tモジュール方式を得るための強力な戦略。
一方でSection 2.4.2のような呼び出しのジソすは2つの明らかな弱点が存在する。
1つはジェネリックインタフェース手続き(real-part, imag-part, magnitude, angle)は全ての異なる表現について知っていなければなりません。
例えば複素数に対する新しい表現を複素数システムに組み入れたいとしましょう。
この新しい表現を型にて識別し、次に全てのジェネリックインタフェース手続きに条項を追加し、その表現に対する適切なセレクタを適用する必要が出てくるでしょう。
もうもう1つのこのテクニックの弱点は例え個々の表現が別々に設計できたとしても、システム全体の中でどの2つの手続きも同じ名前を持たないことを保証せねばならない。
これがなぜAとBがSection2.4.1の彼らの元の手続きの名前を変更しなければいけないかの理由でした。
両者の弱点の根底にある問題はジェネリックインタフェースを実装するためのテクニックがadditive(付加的)でないこと。
ジェネリックセレクタ手続きを実装する人はこれらの手続きを新しい表現がインストールされる度に変更せねばならず、また個々の表現を接続する人々は名前衝突が起こらぬように彼らのコードを変更せねばならない。
これらのケースのそれぞれでコードに対して加えられなければならない変更は簡単だが、それでも必ず行わねばならず、不自由さと障害の原因となる。
これは複素数システムに対して現時点ではあまり大きな問題ではない。
しかしただ2つではなく数百もの異なる表現が複素数に対して存在すると仮定してみてください。
その上どのプログラマもインタフェース手続きや全ての表現について知らないと想定してみてください。
問題は現実的であり大規模なデータベース管理システムのようなプログラムでは必ず解決される必要がある。

