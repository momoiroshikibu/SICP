2.5.2 異なる型のデータを組み合わせる

通常の数値、複素数、分数、そして開発するだろう任意の他の型の数値を包括する統一数値演算システムをどのように定義するかについて学んだ。
しかし私たちは重要な問題を無視してきた。いままで私達が定義した命令は異なるデータの型を完全に独立しているとして扱ってきた。
従って追加すべき分かれたパッケージが、例えば2つの普通の数値や2つの複素数が存在する。
私達がまだ考慮していないことは型の協会を渡る命令を定義することには意義があるという事実。
例えば複素数と実数の加算。私たちはこれまでプログラムの間にバリアを築くための大きな努力をしてきた。
それが分離して開発、理解されることを可能にするため。
私たちは型を渡る命令をある程度注意深くコントロールされた手段にて導入したいと思う。
そうすることで私達のモジュール境界を重大な侵害が起こらないようにそれらをサポートすることができるように。
クロスタイプ(型を渡る)命令を扱う1つの方法は命令が有効な型の可能な組み合わせをそれぞれに対して異なる手続きを設計すること。
例えば複素数パッケージを拡張子、それが複素数と実数の加算を提供し、タグ(complex-scheme-number)を用いてテーブルにインストールできるようにする。

;; to be included in the complex package
(define (add-complex-to-schemenum z x)
  (make-from-real-imag (* (realpart z) x) (imag-part z)))
(put 'add '(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))

このテクニックはうまくいくが、面倒。
このようなシステムでは新しい型を導入するコストはその方のための手続きのパッケージを構築するだけでなく、クロスタイプの命令を実装する手続きの構築とインストールに及ぶ。
これは簡単にその型自身の命令を定義するために必要なものよりより多くのコードとなるでしょう。
この手法はまた分かれたパッケージを付加的に接続する能力を弱めたり、最低でも個々のパッケージの実装者が他のパッケージの考慮をしなければならない範囲を制約する能力をダメにしてしまう。
例えば、上の例では複素数と実数上の混合命令の扱いが複素数パッケージの責任となるのは妥当に見える。しかし分数と複素数の接続においては複素数パッケージで行われるかもしれないし、分数パッケージかもしれないし、これらの2つのパッケージから抽出した命令を用いる何らかの第三者パッケージかもしれない。
パッケージ間の区分上における整合性のポリシーの形式化が、多くのパッケージと多くのクロスタイプ命令を伴ういステム設計について計り知れなくなってしまう。

