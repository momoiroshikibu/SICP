2.5.2 異なる型のデータを組み合わせる

通常の数値、複素数、分数、そして開発するだろう任意の他の型の数値を包括する統一数値演算システムをどのように定義するかについて学んだ。
しかし私たちは重要な問題を無視してきた。いままで私達が定義した命令は異なるデータの型を完全に独立しているとして扱ってきた。
従って追加すべき分かれたパッケージが、例えば2つの普通の数値や2つの複素数が存在する。
私達がまだ考慮していないことは型の協会を渡る命令を定義することには意義があるという事実。
例えば複素数と実数の加算。私たちはこれまでプログラムの間にバリアを築くための大きな努力をしてきた。
それが分離して開発、理解されることを可能にするため。
私たちは型を渡る命令をある程度注意深くコントロールされた手段にて導入したいと思う。
そうすることで私達のモジュール境界を重大な侵害が起こらないようにそれらをサポートすることができるように。
クロスタイプ(型を渡る)命令を扱う1つの方法は命令が有効な型の可能な組み合わせをそれぞれに対して異なる手続きを設計すること。
例えば複素数パッケージを拡張子、それが複素数と実数の加算を提供し、タグ(complex-scheme-number)を用いてテーブルにインストールできるようにする。

;; to be included in the complex package
(define (add-complex-to-schemenum z x)
  (make-from-real-imag (* (realpart z) x) (imag-part z)))
(put 'add '(complex scheme-number)
     (lambda (z x) (tag (add-complex-to-schemenum z x))))

このテクニックはうまくいくが、面倒。
このようなシステムでは新しい型を導入するコストはその方のための手続きのパッケージを構築するだけでなく、クロスタイプの命令を実装する手続きの構築とインストールに及ぶ。
これは簡単にその型自身の命令を定義するために必要なものよりより多くのコードとなるでしょう。
この手法はまた分かれたパッケージを付加的に接続する能力を弱めたり、最低でも個々のパッケージの実装者が他のパッケージの考慮をしなければならない範囲を制約する能力をダメにしてしまう。
例えば、上の例では複素数と実数上の混合命令の扱いが複素数パッケージの責任となるのは妥当に見える。しかし分数と複素数の接続においては複素数パッケージで行われるかもしれないし、分数パッケージかもしれないし、これらの2つのパッケージから抽出した命令を用いる何らかの第三者パッケージかもしれない。
パッケージ間の区分上における整合性のポリシーの形式化が、多くのパッケージと多くのクロスタイプ命令を伴ういステム設計について計り知れなくなってしまう。



型の強制
完全に依存しない型の上で振る舞う完全に依存しない命令群が一般的な状況においては明示的にクロスタイプ命令を実装することは面倒かもしれませんが、人が望む最高のものかもしれません。
幸運なことに私たちは通常、私達の型システム内の潜在的に存在するだろう付加的な構造の利点を用いることによりより良く行うことが可能。
時折、異なるデータの型は完全には独立しておらず、ある型のオブジェクトが他の型であるように見られる場合が複数存在するでしょう。
この過程はcoercion(強制)と呼ばれます。
例えばもし私達が算術上、実数と複素数を合成するように求められた場合に、私たちは実数を虚数部が0の複素数だと見なすことができます。
これはこの問題を2つの複素数の合成へと変換し、複素数パッケージにより通常の方法にて取り扱うことが可能になります。

一般的に、ある型のオブジェクトを等価な他の型のオブジェクトに変換する強制手続きを設計することでこの考えを実装することができる。
(define (scheme-number->complex n)
  (make-complex-from-real-imag (contents n) 0))

これらの強制手続きを2つの型の名前により索引付した特別な強制テーブルにインストールする。

(put-coercion 'schem-enumber
              'complex
              scheme-number->complex)

一般にこのテーブルの枠のいくつかは空になる。
全ての型の任意のデータオブジェクトを全て他の方へと強制することは一般には不可能。
例えば任意の複素数を実数に強制することはできない。
そのため普遍的なcomplex->scheme-number手続きはテーブルに含まれることはない。

強制テーブルが準備されればapply-generic手続きを変更することで統一的な作法で強制を取り扱うことができる。
命令を適用するように求められた時、最初にそのお命令が引数の型に対して定義されているかどうかを以前と同様にチェックする。
もしそうであれば命令と型のテーブルで見つかった手続きを呼び出す。
そうでなければ強制を試みる。強制テーブルをチェックし、最初の型のオブジェクトが2つ目の型に強制できるか確認する。
もしそうであれば、最初の最初の引数を強制し、命令の試行を再び行う。
もし最初の型のオブジェクトが一般に2つ目の型に強制できない場合、逆に2つ目の引数を1つ目に強制できるか試す。
最後にどちらの方も他方の型に強制できない場合、あきらめる。

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (if (= (length args) 2)
              (let ((type1 (car type-tags))
                    (type2 (cadr type-tags))
                    (a1 (car args))
                    (a2 (cadr args)))
                (let ((t1->t2 (get-coercion type1 type2))
                      (t2->t1 (get-coercion type2 type1)))
                  (cond (t1->t2
                         (apply-generic op (t1->t2 a1) a2))
                        (t2->t1
                         (apply-generic op a1 (t2->t1 a2)))
                        (else (error "No method for these types"
                                     (list op type-tags))))))
              (error "No method for these types"
                     (list op type-tags)))))))

この強制スキームは上で概説されたように明示的なクロスタイプ命令の定義手法上に多くの利点を持つ。
私たちは型に関係する強制手続きを書かねばなりませんが(n個の型システムに対し場合によりn^2の手続き)、
全ての型の集合と書くジェネリック命令に対し異なる手続きを書くのでなく、型のペア1組につき1つの手続きを書くだけで済みます。
ここで私達が信頼しているものはタイプ間の適切な変換は型それ自身のみに依存し、適用される命令には依存しないという事実です。
一方で、私達の強制スキームが充分に汎用ではないアプリケーションが存在するかもしれません。
たとえ合成されるオブジェクトの両方共が他方に変換出来ないとしても両方を第三の型に変換することで命令を実行することが可能になるかもしれない。
そのような複雑さに対処するため、そしてそれでもプログラムのモジュール方式を維持するために、通常はよりいっそうタイプ間の関係の構造の利点を得るシステムを構築することが、次で議論するように必要。


型の階層
上で展開された強制スキームは型のペアの間の自然な関係の存在に当てにしていました。
より一般的な構造が、異なる型のお互いへの関係の仕方にはよく存在します。
例えば、私達が整数、分数、実数、複素数を扱う一般的な数値演算システムを構築していると仮定する。
そのようなシステムにおいては整数を特別な種類の分数として見なすことはとても自然。
分数はどうように特別な種類の実数であり、実数はどうように特別な種類の複素数。
私達が実際に手にしているものはhierarchy of types(型の階層)と呼ばれるもので、その中では例えば整数は分数のsubtype(サブタイプ)。
(すなわち分数に適用できる任意の命令は自動的に整数に適用できる)。
逆に分数は整数のsupertype(スーパータイプ、親の型)と呼ぶ。
いま手にした階層はとても単純な種類で、各型はたかだか1つのスーパータイプを持ち、たかだか1つのサブタイプを持つ。
そのような構造はタワーと呼ばれる。
もしタワー構造を持つ場合、階層に新しい方を追加する問題を著しく単純化できる。
新しい型がどのようにその上のスーパータイプの隣に組み込まれるか、そしてどのようにその型がその下の型に対してスーパータイプであるかを指定するだけ。
例えばもし複素数に対して整数を追加したい場合、明示的に特別な強制手続きinteger->complexを定義する必要はない。
その代わりに
整数がどのように分数に変換できるか、
分数がどのように実数に変換できるか、
実数がどのように複素数に変換できるか
を定義する。
そうしたらシステムに整数を複素数に変換することをこれらのステップを通して変換することを許可し、次に2つの複素数を加算する。
apply-generic手続きを以下のように再設計することもできる。
各型に対してraise手続きを与える必要がある。これはある型のオブジェクトをタワーにおいて1レベル上げる。
そうすればシステムが異なる型のオブジェクト上にて操作する必要がある場合、全てのオブジェクトがタワー内にて同じレベルになるまで連続して上げることが出来る。

タワーの別の利点には全ての型がスーパータイプ上に定義された全ての命令を軽傷する概念を簡単に実装できることが挙げられる。
例えばもし整数の実数部を求めるための特別な手続きを提供しない場合、それにもかかわらず整数は複素数のサブタイプであるという事実のおかげで、整数のためのreal-partが定義されることが期待できる。
タワーではapply-genericを変更するという解いうつ的な方法でこのようなことが起こるよう準備することが可能。
もし必要な命令が与えられたオブジェクトの型のために直接定義されていない場合、オブジェクトをそのスーパータイプに上げる事で再思考できる。
従ってタワーを這い上がりながら望まれた命令が実行可能になるまで引数を変換するか、頂上までたどり着いてそこで諦めることができる。

別のより一般的な階層に比べた場合、もうひとつのタワーの利点はデータオブジェクトをより簡単な表現へ下げる方法を提供すること。
たとえば2/3iを4-3iに足した場合、その答えは複素数6+0iよりも整数6で得るほうが良いと言えるでしょう。


