3.1.3 代入導入のコスト

set!はローカルな状態を持つオブジェクトのモデル化を可能にする。しかし、この利点は犠牲を伴う。
代入を使わないかぎり、同じ引数を伴う同じ手続きの二度の評価は同じ結果を生じ、手続きは数学上の関数の計算と見ることができる。
代入を使用しないプログラミングは、それゆえにfunctional programming(関数型プログラミング)として知られている。

(define (make-simplified-withdraw balance)
  (lambda (amount)
    (set! balance (- balance amount))
    balance))
(define W (make-simplified-withdraw 25))
(W 20)
5
(W 10)
-5

この手続と以下のset!を使用しないmake-decrementer手続きとを比べてみてください。

(define (make-decrementer balance)
  (lambda (amount)
    (- balance amount)))

make-decrementerは指定された残高balanceからその入力を引く。
しかし連続した呼び出しにおいて、make-simplified-withdrawのような累積効果はない。
(define D (make-decrementer 25))
(D 20)
5
(D 10)
15

makd-decrementerがどのように働くのかの説明には置換モデルを使用できる。
((make-decrementer 25) 20)

最初に結語のオペレーターをmake-decrementerのボディのbalanceを25と置き換えることにより節約する。

((lambda (amount) (- 25 amount)) 20)

lambda式のボディにあるamountを20と置き換えることでオペレーターを適用する

(- 25 20)
最終的な答えは5

しかしもしmake-simplified-withdrawに対しても同様の置換分析を試みれば何が起こるか観察してみてください。

((make-simplified-withdraw 25) 20)
最初にmake-simplified-withdrawのボディにあるbalanceを25に置き換えることでオペレーターを簡約する。

((lambda (amount) (set! balancee (- 25 amount))) 20)

ここでlambda式のボディの中のamountを20に置き換えてオペレータを適用する

(set! balance (- 25 20)) 25

もし置換モデルに執着するのであれば、手続きの適用の意味は最初にbalanceを5に設定し、次に式の値として25を返すと言わざるを得ない。
これは間違った答えを得る。
正しい答えを得るためには、どうにかして最初の位置のbalance(set!の高改善)を2つ目のbalance(set!の効果の後)から区別せねばならない。
そして置換モデルはこれを行うことができない。
ここでの問題は置換はつまるところ、本質的に値の名前であるという概念に基づいている。
しかしset!と変数の値が変更できるという考え方を紹介してからすぐに、変数はもはや単純な名前ではない。
今では変数はどうにかして値が格納できる場所を参照し、その場所に格納された値は変更することがカノ王。


同一性と変更

ここで表出した問題は特定の演算モデルが単に崩壊したよりもずっと深い。
計算モデルに変更を紹介してすぐに、以前は簡単であった多くの概念が難問と化す。
2つのものが同じであるという概念について考えてみましょう。
make-decrementerを同じ引数を与えて二度呼び、2つの手続きを作成したとする。

(define D1 (make-decrementer 25))
(define D2 (make-decrementer 25))

D1とD2は同じか？無難な答えはYESとなる。
D1とD2は同じ計算上の振る舞いを持ち、それぞれが入力から25を引く手続き。
実際にD1は任意の計算において結果を変えること無くD2の代替にできる。
これとmake-simplified-withdrawの二度の呼び出しとを対比する。

(define W1 (make-simplified-withdraw 25))
(define W2 (make-simplified-withdraw 25))

W1とW2は同じでしょうか？もちろん違います。
W1とW2の呼び出しは区別可能な効果を持つ。
(W1 20)
5
(W1 20)
-15
(W2 20)
5

例えW1とW2が同じ指揮(make-simplified-withdraw 25)を評価することで作成されたという点で同じであっても、W1が式の評価の結果を変えずに任意の式でW2の代替になるかというのは正しくない。
式において式の値を変化せずに等しい物は等しいもので置き換えられるという概念を指示する言語はreferentially transparent(参照透明)と呼ばれる。
参照透明は私達の計算機言語にset!を含めた時侵害された。
これがいつ式を等価な式で置き換えることで監訳できるかを決定することを扱いにくくする。
結果的に、代入を用いるプログラムについての推測は大幅により難しくなる。

参照透明を無しですませば、計算オブジェクトが同じであることの意味する概念が形式的に捉えることが難しくなる。
本当に実際の世界での等価の意味は私達のプログラムモデルにおいて全く明確になりません。
一般的に2つのおそらく同じオブジェクトが本当に同じものであるかは一方のオブジェクトを変更した場合にもう一方のオブジェクトが同様に変化したかを観察するしか手立てがない。
しかしオブジェクトが変更されたことを同じオブジェクトを2回観察し、オブジェクトのある属性が1回目の観察から次に対して異なるかどうかを見る意外にどうやって判断できるのか。
従って同一視詠の何らかのa priori(先験的な)概念なしに変化を判断することができない。
そして変化の結果を観察せずに同一性を判断することはできない。

(define peter-acc (make-account 100))
(define paul-acc (make-account 100))

以下の定義では大きな違いがある。
(define peter-acc (make-account 100))
(define paul-acc peter-acc)

最初の状況では、2つの銀行口座は区別できる。
Peterにより行われた取引はPaulの口座には影響を与えない。逆も同じ。
2つ目の状況ではしかし、paul-accがpeter-accと同じものになるよう定義した。
実際にPeterとPaulはpaul-accの残額が減ったことを観察するでしょう。
これらの2つの似ているが区別できる状況は計算モデルの構築において混乱の元となり得る。
具体的には、共有口座のために1つのオブジェクトが2つの異なる名前を持つことは特に混乱する。
プログラムの中でpaul-accを変更することができる箇所をすべて探す場合、peter-accを変更する箇所もまた探さねばならないことを覚えて置かなければならない。

上記の同一性と変更上の見解への参照と共に、もしPeterとPaulは差し引き残高を調べられるだけで差し引き残高を変更する命令を実行出来ない場合、2つの口座が区別できるかどうかという問題が無意味になるのかについて注意。
一般的に、データオブジェクトを変更しないかぎり、複合データオブジェクトをまさにそれの部分の全体であると見なすことが出来る。
例えば、分数はその分子と分母により決定される。
しかしこの見方は変更が存在するときには、複合データオブジェクトがそれが組み立てられている部品とは異質のアイデンティティ(自己同一性)を持つ場合には有効ではない。
銀行口座は例え引き出しを行うことで残高を変更しても依然として同じ銀行口座。
反対に、同じ状態情報を持つ2つの異なる銀行口座を持つことも出来る。
この複雑さはプログラミング言語によるものではなく、私達のオブジェクトとしての銀行口座の認知によるもの。
例えば私たちは通常分数を同一性を保ちながら変更可能なオブジェクトだとはみなしません。
分子を変更したら同じ分数だとは思わない。

