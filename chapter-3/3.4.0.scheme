3.4 並行性: 時間が本質

参照透過性を失うことは透過性と変更に関する問題のチケットを増加し、評価の置換モデルを断念し、より難解な環境モデルの支持を必要とする。
状態、透過性、変更の複雑さの下に潜んでいる中心的課題は、代入を導入することにより私たちは計算モデルの中にtimeの存在を認めることを強制されること。
代入の導入前は私達のプログラム全ては値を持つ任意の式が常に同じ値を持つという意味において恒久的だった。

(withdraw 25)
75
(withdraw 25)
50

ここでは同じ指揮の一連の評価が異なる値を生じている。
この振る舞いは代入文の実行(この場合では変数balanceへの代入)が値が変化しtあmoments in time(時間の瞬間)を描いている。
式の評価の結果は式自身だけではなく、これらの瞬間の前か後に評価が行われたかにも依存する。
局所状態を持つ計算モデルを用いたモデルの構築は私たちにプログラミングにおける本質的な概念としての時間に直面することを強いる。

計算モデルの構造化において物理世界の私達の認知を一致させることをより勧めることは可能。
世界の中のオブジェクトは一時に1つが順に変わることはありません。
そうではなく、わたしたちはそれがconcurrently(並行)に-同時に-行動することを知覚する。
そのためシステムを平行に実行する計算処理の集合であるとモデル化することは多くにおいて自然。
分離された局所状態を持つオブジェクトを用いてモデルを体系化することにより私達のプログラムをモジュラーかするのと同様に、計算モデルを別々に、平行に発展する部分に分割することは多くの場合に適切。
たとえプログラムが逐次的な計算機により実行されるとしてもプログラムを平行に実行される前提で書くことを練習することはプログラマに不必要な制約を防ぐことを強いるため、プログラムをよりモジュール式にする。

並行演算は逐次的演算に速度上の利点を与えることが可能。
逐次的演算は一時に1つの命令のみを実行するためタスクの実行にかかる時間料は実行される命令の送料に比例する。
しかしもし問題を相対的に独立した部分に分割することが可能で、まれにしか通信を行う必要がなければ、それらの部分を異なる計算機に配置し、存在する計算機の数に比例した速さの利点を生じることが可能となるでしょう。

残念なことに、代入により持ち込まれた複雑性は並行性の出現により、よりいっそう難しくなる。
並行実行の結果は世界が並列に作動するためか計算機がそれを行うためかによらず、私達の時間の理解にさらなる複雑性をもたらす。
