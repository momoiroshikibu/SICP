3.4.1 並行システム内の時間の性質

時間はイベントに課される順序付け。
任意のイベントAとBに対し、AがBの前に起こるか、AとBが同時か、AがBの後に起こるか。


(define (withdraw amount)
  (if (>= balance amount)
      (begin
        set! balance (- (balance amount)) balance)
      "Insufficient funds"))

並行プログラムの正しい振る舞い
複雑性の根本は異なるプロセスの間で共有される変数への代入に横たわっている。
私たちはすでにset!を用いるプログラムを書く場合には気をつけなければならないことを知っている。
計算の結果が代入の起こる順序に依存するため。
並行プロセスでは特に代入に気をつけなければならない。異なるプロセスにより作られる代入の順をコントロール出来ないかもしれないため。
もしいくつかのそのような変更が平行に行われるのであれば私達のシステムの振る舞いが正しいことを確認するための何らかの方法を必要とする。
例えば、連結口座からの引き出しの場合、お金が保管されていることを確認しなければならない。
並行プログラムの振舞を正しくするために、平行実行に何らかの制限を置かねばならない。
並行性への可能な1つの制限は、任意の共有状態変数を変更するどの2つの命令も同時には起こりえないこと。
これはとても厳しい制限。分散銀行システムではシステム設計に対しただ1つの取引だけが一時に手続きできることを保証することを要求する。
これは非効率であり、かつ過度に保守的。

並行性上の比較的厳しくない制限は並行システムがまるでプロセスが同じ順に逐次的に実行されたかのように同じ結果を生成することを保証する。
2つの重要な側面がこの制限にはある。第一にプロセスに対し実際に逐次的に実行することを要求はしないが、あたかも逐次的に実行された場合と同じ結果を生成することを要求する。
並行プログラムの正しい実行のためのより弱い要件はまだある。
拡散のシミュレーションのプログラムは巨大な数のプロセスから成り、各プロセスは小容量の空間を表し、その値を並行に更新する。
各プロセスはその値を、その値と近傍の平均へと繰り返し変更する。
このアルゴリズムは命令が行われる順から独立して正しい答えに収束する。
共有地の並行な使用上にどんな制限も必要としない。
