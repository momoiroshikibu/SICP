4.1.5 プログラムとしてのデータ

プログラムの意味についての命令上の視点の1つに、プログラムは(おそらく無限に大きな)抽象機械の記述であるというものがあります。
例えば会場を計算する親しみのあるプログラムについて考えてみましょう。
(define (factorial n)
  (if (= n 1) 1 (* (factorial (- n 1)) n)))

私たちはこのプログラムを減算、乗算、等価試験の部品と一緒に2つの位置をもつスイッチと他の累乗機械を含める機械の説明であるとみなすことができるでしょう。
(階乗機械は無限。他の階乗機械をその中に含んでいるため。)
同様な方法で、評価機を入力として機械の説明書を取るとても特殊な機械だとみなすことができます。
この入力を与えられると、評価機はそれ自身を記述された機械を真似るように設定します。
例えばもし評価機に示されるfactorialの記述を与えれば、評価機は階乗の計算ができるようになる。
この視点からは、私達の評価機はunivrsal machine(万能機械)であると見えます。
他の機会がLispにて説明されるとき、それを真似します。

プログラミング言語により操作されるデータオブジェクトとプログラミング言語それ自身とのブリッジとして働く。
Lispで実装された評価機プログラムが実行中であり、ユーザーが式をその評価機に入力し結果を観察していると想像してみてください。
ユーザーの視点からは(* x x)のような入力式はプログラミング言語による式であり、評価機が実行すべきもの。
しかし、評価機の視点からは式は単純なリスト(この場合では*, x, x)であり、これは明確なルール集合に従って操作されねばならぬもの。

ユーザーのプログラムが評価機のデータだということは混乱の元となる必要はない。
実際、時々はこの区別は無視したほうが便利。
そしてユーザーに対し明示的にデータオブジェクトをLispの式として評価する能力をeval手続きをプログラム中で使用できるようにすることで与えることもまた便利なこと。多くのLisp方言は引数として式と環境を取り、その環境に関連してその指揮を評価するプリミティブなeval手続きを与える。
したがって、この両方は25を返す。
(eval '(* 5 5) user-initial-environment)
(eval (cons '* (list 5 5)) user-initial-environment)
