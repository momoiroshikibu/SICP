4.1.6 内部定義

評価の環境モデルとメタ循環評価機は定義を順に実行し、環境のフレームを1度に1定義ずつ拡張する。
これはインタラクティブなプログラム開発については特に便利。
その場合にはプログラマは自由に手続きの適用を新しい手続きの定義に混ぜる必要がある。
しかし、ブロック構造を実装するために用いられた内部定義について注意深く考えてみれば、環境の前ごとの拡張はローカル変数の定義に最良の方法ではないのではと気づくのではないでしょうか。
内部定義を伴う以下の様な手続きについて考えてみます。

(define (f x)
  (define (even? n) (if (= n 0) true (odd? (- n 1))))
  (define (odd? n) (if (= n 0) false (even? (- n 1))))
  <rest of body of f>)

ここでの意図は手続きeven?のボディ内の名前odd?はeven?の後に定義された手続きodd?を参照しなければなりません。
名前odd?のスコープはfのボディ全体であり、odd?の定義が起こった箇所からはじまるfのボディの一部分ではない。
実際にodd?がそれ自身even?を用いて定義されていることについて考えると
even?とodd?は相互再帰手続きであり、2つのdefineを満たせる解釈はそれらを名前even?とodd?が環境に同時に追加されたとみなすことのみ。
より一般的には、ブロック構造において、ローカルな名前のスコープはdefineが評価された手続きのボディ全体だということ。
内部手続の定義が最初に来るため、これらの手続きの呼び出しはそれらのすべてが定義されるまで怒らない。
したがって、odd?はeven?が実行された時に定義される。
内部手続がボディの最初に着て定義された変数の値の式の評価が実際にはどの定義された変数も用いない任意の手続きに対し直接、同時定義を実装する仕組みと、私達の逐次的な評価システムの仕組みはじd祭に同じ結果を与えます。
(これらの制限に従わず、その結果逐次定義が同時定義と等価でない手つきの例に対してはExercise4.19を参照)
しかし内部定義の名前が真に同時にスコープを持つようになる簡単な定義の扱い方が存在する。
単に現在の環境に入ることになる全てのローカル変数はどの値の指揮が評価されるよりも早く作成すること。
これを行う1つの方法はlambda式条の構文変形による。
lambda式のボディを評価する前に、ボディの中のすべての内部定義を走査し、削除します。
内部で定義された変数はletを用いて作成され、次に代入を用いてそれらの値に設定される。
(lambda <vars>
  (define u <e1>)
  (define v <e2>)
  <e3>)

これは以下に変形される。
(lambda <vars>
  (let ((u '*unassigned*)
        (v '*unassigned*))
    (set! u <e1>)
    (set! v <e2>)
    <e3>))


ここで*unassigned*は特別なシンボルであり、変数が調べられた時に、もしまだ値が割り当てられていない変数を使用しようとしたならばエラーを発する。
