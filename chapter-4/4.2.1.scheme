4.2.1 正規順と適用順

Schemeはapplicative-order(適用順序)言語。
Schemeの手続きへのすべての引数は手続きが適用される時に評価される。
逆に、normal-order(正規順序)言語は手続き引数の評価を実際に引数の値が必要とされるまで遅らせる。
手続き引数の評価を可能な限り最後の瞬間まで(例えばプリミティブ命令により必要とされるまで)遅らせることはlazy evaluation(遅延評価)と呼ばれる。

(define (try a b) (if (= a 0) 1 b))

(try 0 (/ 1 0))の評価はSchemeではエラーを生成する。
遅延評価ではエラーは現れない。
その式の評価は1となる。なぜなら絶対に引数は評価されないから。
遅延評価を利用した例で、手続きunlessの定義。

(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))

これは以下の様な式で使用できる。
(unless (= b 0)
        (/ a b)
        (begin display "exception: returning 0" 0))
これは適用順序の言語では動かない。
通常値と例外地の両方がunlessを呼ぶ前に評価されるため。
遅延評価の利点はunlessのような手続きはたとえそれらの引数の幾つかの評価がエラーを発生したり、停止しなかったとしても役立つ計算ができる。
引数の評価が完了する前に手続きのボディに入ることを、手続きがその引数においてnon-strict(非厳密)であると呼ぶ。
もし引数が手続きのボディに入る前に評価されたなら手続きはその引数に対しstrict(厳密)であると言う。
純粋適用順序言語ではすべての手続がすべての引数に対し厳密。
そしてプリミティブな手続きは厳密にも非厳密にもなり得る。
またプログラマに彼らが定義する手続きの厳密さにこまかなコントロールを提供する言語もある。
実用性のために非厳密にすることができる手続きの印象的な例にはcons(または一般的に、ほとんどすべてのデータ構造のコンストラクタ)がある。
たとえもし要素の値がわからなくても、データ構造を形成するよう要素を組み立て、結果のデータ構造上で操作をする実用的な計算を行える。
例えばリストの長さをリスト内の個々の要素の値を知ることなしに計算することは完璧に意味がある。
私たちはこの考えを非厳密なconsペアにより形成sれたリストとしてストリームを実装するために利用する。

