4.4.1 演繹的情報検索

単純なクエリ
クエリ言語はユーザーにシステムプロンプトに対応する応答としてクエリを提示することで、データベースから情報を取得することを許す。

(job ?x (computer programmer))

(job (Hacker Alyssa P) (computer programmer))
(job (Fect Cy D) (computer programmer))

入力クエリはある種のパターンにマッチするデータベース内のエントリを探すことを指示する。
この例では、パターンは3つの項目からなるエントリを指定している。
最初が文字シンボルのjob、2つ目は任意の値になりえて、3番めは文字のリスト(computer programmer)
マッチングリスト内の2つ目の項目になり得る人以降はパターン変数?xで指定される。
パターン変数の一般的な形式はクエスチョンマークを前においた、変数の名前としてとられるシンボル。

パターンは複数の変数を持つことができる。
(address ?x ?y)
はすべての従業員の住所を調べる。

パターンはクエリが単純にパターンがデータベース内のエントリであるかどうかを決定する場合には変数を持つことができない。
もしそうであれば1つの一致が存在する。そうでなければ1つも一致は存在しない。
同じパターン変数が1つのクエリ内に複数存在することができ、同じ任意項が各市に現れなければいけないことを指定する。
これがなぜ変数が名前を持つのかの理由。

システムはクエリパターン内の変数に対する、パターンを満たすすべての割当を見つける。
つまり、パターン変数が値によりインスタンス化されるような(例示されるような)、つまり値により置き換えられるような変数に対する値のすべての集合。
結果はデータベース内に存在する。

システムはクエリに対し、パターンを満たす変数割当と共に、クエリパターンのすべてのインスタンス(事例)を列挙することで応答する。

もしパターンに変数がない場合、クエリはそのパターンがデータベース内に存在するかどうかの決定に簡約されることに注意。
もしそうならば、変数になんの値も割り当てないから割当がデータベースに対するそのパターンを満たす。


複合クエリ
単純なクエリはクエリ言語のプリミティブな命令を形成する。
複雑な命令を形成するためには、クエリ言語は組み合わせの手段を提供する。
クエリ言語を論理プログラミング言語となすものの一つに組み合わせの手段が論理式を形成するのに用いられる組み合わせの手段に酷似することがあげられる。
and, or, notです。andを以下のように用いてすべてのコンピュータプログラマの住所を見つけることができる。
(and (job ?person (computer programmer))
     (address ?person ?where))

簡単にクエリに関しては、システムはクエリを満たすパターン変数へのすべての割当を見つけることにより複合クエリを処理する。
そしてそれらの値によるクエリのインスタンスを表示する。

(lisp-value <predicate> <arg1> ... <argn>)
lisp-valueがパターンの最初の要素の時、次の要素はインスタンス化された残りの要素を引数としてて供されるLispの述語であることを意味する。
(and (salary ?person ?amount) (lisp-value > ?amount 30000))


ルール
(rule (lives-near ?person-1 ?person-2)
      (and (address ?person-1 (?town . ?rest-1))
           (address ?person-2 (?town . ?rest-2))
           (not (same ?person-1 ?person-2))))

ルールの一般的な形式は以下となる。
(rule <conclusion> <body>)
<conclusion>がパターンであり<body>が任意のクエリ。
ルールは大きなアサーションの集合を表現するものとして考えることができる。
すなわち、ルールのボディを満たす変数の割当を用いたルールの結果のすべてのインスタンス。
簡単なクエリを説明した時、変数への割当はインスタンス化されたパターンがデータベース内に存在する場合にパターンが満たされると説明した。
しかし、パターンは明示的にアサーションとしてデータベース内に存在する必要はない。
ルールにより暗示されて暗黙的なアサーションになり得る。　


プログラムとしての論理
クエリ言語はルールを元にしたlogical deductions(論理的推理)を実行する能力を有するとみなすことができる。

(append-to-form x y z)
上の関係はxとyのappendはzを形成することを意味すると解釈できる。

(rule (append-to-form () ?y ?y))
(rule (append-to-form (?u . ?v) ?y (?u . ?z))
      (append-to-form ?v ?y ?z))

最初のルールにはボディが内。
これは結果部分が?yの任意の値を保持することを意味する。
2つ目のルールがどのようにドット付き末尾記述をリストのcarとcdrに名前をつけるために使用しているかについて注意。
これらの2つのルールを与えられることで、2つのリストに対するappendを求めるクエリを定式化できる。
(append-to-form (a b) (c d) ?z)
(append-to-form (a b) (c d) (a b c d))
より印象的なのは同じルールを"(a b)に対しappendしたら(a b c d)になるリストは何"という質問に使用できること。

システムはルールを解きほぐす明確なアルゴリズムに従っているに過ぎない。
