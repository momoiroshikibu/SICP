5.3.1 ベクタとしてのメモリ

伝統的なコンピュータのメモリは小さな部屋の配列だと考えることができる。
各部屋は情報の一変を入れることができる。
各部屋はaddressまたはlocationと呼ばれる固有の名前を持つ。典型的なメモリシステムは2つのプリミティブな命令を提供する。
1つは指定された位置に格納されたデータを取り出し、もう一つは指定された位置に新しいデータを割り当てる。
メモリアドレスはある部屋の集合にシーケンシャルなアクセスをサポートするためにインクリメントすることができる。
より一般的には、多くの重要なデータの操作はメモリアドレスをデータとして扱うことを要求します。
このデータはメモリ上の位置に格納でき、機械のレジスタ上で操作できなければいけない。
リスト構造の表現はそのようなaddress arthmetic(アドレス演算)の一つの応用。

コンピュータメモリをモデル化するためには、vectorと呼ばれるアタrしい種類のデータ構造を用いる。
抽象的には、ベクタは複合データオブジェクトであり、その個別の要素が整数の索引を用いて、索引から独立した時間料でアクセスすることができる。
メモリ操作をせつめいするために、ベクタを扱うための2つのプリミティブなScheme手続きを使用する。

(vector-ref <vector> <n>)はベクタのn番目の要素を返す
(vector-set! <vector> <n> <value>)はベクタのn番目の要素に指定された値を設定する

例えば、vがベクタであるならば、(vector-ref v 5)はベクタvの5番めの項目を取得し、
(vector-set! v 5 7)はベクタvの5番めの項目の値を7に変更する。
コンピュータメモリに対して、このアクセスはアドレス演算を用いて、メモリ内のベクタの開始位置を指定するbase addressとベクタの特定の項目のオフセットを指定するindexを組み合わせることで実装することができる。


Lispデータの表現
ベクタを用いてリスト構造メモリに対する基本的なペア構造を実装することができる。
ペアに対するポイントは2つのベクタへの索引。
ペアのcarはthe-carsに指定した索引を用いた項目。
ペアのcdrは指定された索引を用いたthe-cdrsの項目。
ペア意外のオブジェクト(例えば数値やシンボル)に対する表現とデータの種類をお互いに見分けるための手法も必要になる。
これを達成する方法は多数存在するが、しかしそれらはすべてtyped pointers(型付きポインタ)の使用へと帰す。
これはつまり、ポインタの概念を拡張しデータの方の情報を含めること。
データの方はシステムにペアのポインタ(ペアデータ型とメモリベクタを指す索引から成り立つ)を他の種類のデータへのポインタ(何らかの他のデータ型とその方を表現するために利用された何かにより成り立つ)を見分けることを可能にする。
2つのデータオブジェクトはそれらのポインタが全く同じである場合に同じ(eq?)だと判断される。

readerは伝統的にobarray(オブジェクト配列)と呼ばれる出会ったすべてのシンボルのひょうを管理する。
readerが文字列に遭遇しシンボルを構築しようとするとき、obarrayをチェックし同じ文字列を以前に見ていないか確認する。
もし初見であれば、文字列を用いて新しいシンボル(新しい文字列に対する型付きポインタ)を構築し、このポインタをobarrayに挿入する。
もしreaderがすでにその文字列を見ていれば、obarrayに格納されているシンボルのポインタを返す。
この文字列を一意なポインタで置き換える処理はシンボルのinterning(抑留)と呼ばれる。


プリミティブなリスト命令の実装
レジスタマシンの各プリミティブなリスト命令を複数のプリミティブなベクタ命令で置き換えることができる。
2つのレジスタthe-carsとthe-cdrsを用いてメモリベクタを特定し、vector-refとvector-set!がプリミティブな命令として有効であると仮定します。
またポインタ上の演算命令(例えばポインタをインクリメントする、ペアのポインタを用いてベクタを索引付する、または2つの数値を足す)は型付きポインタの索引部分しか利用しません。
例えば、次の命令をサポートするレジスタマシンをその下の条件の下で作成することが出来る。
(assign <reg1> (op car) (reg <reg2>))
(assign <reg1> (op cdr) (reg <reg2>))

上の命令のそれぞれに対し、これらが実装されているとする。
(assign <reg1> (op vector-ref) (reg the-cars) (reg <reg2>))
(assign <reg1> (op vector-ref) (reg the-cdrs) (reg <reg2>))

以下の命令は、

(perform (op set-car!) (reg <reg1>) (reg <reg2>))
(perform (op set-cdr!) (reg <reg1>) (reg <reg2>))

次のように実装される。

(perform
 (op vector-set!) (reg the-cars) (reg <reg1>) (reg <reg2>))
(perform
 (op vector-set!) (reg the-cdrs) (reg <reg1>) (reg <reg2>))

consは未使用の索引を割り当て、consの引数をthe-carsとthe-cdrsの中で索引付けられたベクタの位置に格納します。
私たちは特別なレジスタ、freeが存在し、常に次に使用可能な索引を持つペアポインタを保つと仮定する。
そしてそのポインタの索引部分をインクリメントすることで次の秋位置を探すことができる。

(assign <reg1> (op cons) (reg <reg2>) (reg <reg3>))

次の一連のベクタ命令として実装される。

(perform
 (op vector-set!) (reg the-cars) (reg free) (reg <reg2>))
(perform
 (op vector-set!) (reg the-cdrs) (reg free) (reg <reg2>))
(assign <reg1> (reg free))
(assign free (op +) (reg free) (const 1))

以下のeq?命令は
(op eq?) (reg <reg1>) (reg <reg2>)

単純にレジスタ内のすべての項目の等価性をテストする。
そしてpair?, null? symbol? number?のような述語は型フィールドのみを確認する必要がある。


