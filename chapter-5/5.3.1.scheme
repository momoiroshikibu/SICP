5.3.1 ベクタとしてのメモリ

伝統的なコンピュータのメモリは小さな部屋の配列だと考えることができる。
各部屋は情報の一変を入れることができる。
各部屋はaddressまたはlocationと呼ばれる固有の名前を持つ。典型的なメモリシステムは2つのプリミティブな命令を提供する。
1つは指定された位置に格納されたデータを取り出し、もう一つは指定された位置に新しいデータを割り当てる。
メモリアドレスはある部屋の集合にシーケンシャルなアクセスをサポートするためにインクリメントすることができる。
より一般的には、多くの重要なデータの操作はメモリアドレスをデータとして扱うことを要求します。
このデータはメモリ上の位置に格納でき、機械のレジスタ上で操作できなければいけない。
リスト構造の表現はそのようなaddress arthmetic(アドレス演算)の一つの応用。

コンピュータメモリをモデル化するためには、vectorと呼ばれるアタrしい種類のデータ構造を用いる。
抽象的には、ベクタは複合データオブジェクトであり、その個別の要素が整数の索引を用いて、索引から独立した時間料でアクセスすることができる。
メモリ操作をせつめいするために、ベクタを扱うための2つのプリミティブなScheme手続きを使用する。

(vector-ref <vector> <n>)はベクタのn番目の要素を返す
(vector-set! <vector> <n> <value>)はベクタのn番目の要素に指定された値を設定する

例えば、vがベクタであるならば、(vector-ref v 5)はベクタvの5番めの項目を取得し、
(vector-set! v 5 7)はベクタvの5番めの項目の値を7に変更する。
コンピュータメモリに対して、このアクセスはアドレス演算を用いて、メモリ内のベクタの開始位置を指定するbase addressとベクタの特定の項目のオフセットを指定するindexを組み合わせることで実装することができる。


Lispデータの表現
ベクタを用いてリスト構造メモリに対する基本的なペア構造を実装することができる。
ペアに対するポイントは2つのベクタへの索引。
ペアのcarはthe-carsに指定した索引を用いた項目。
ペアのcdrは指定された索引を用いたthe-cdrsの項目。
ペア意外のオブジェクト(例えば数値やシンボル)に対する表現とデータの種類をお互いに見分けるための手法も必要になる。
これを達成する方法は多数存在するが、しかしそれらはすべてtyped pointers(型付きポインタ)の使用へと帰す。
これはつまり、ポインタの概念を拡張しデータの方の情報を含めること。
データの方はシステムにペアのポインタ(ペアデータ型とメモリベクタを指す索引から成り立つ)を他の種類のデータへのポインタ(何らかの他のデータ型とその方を表現するために利用された何かにより成り立つ)を見分けることを可能にする。
2つのデータオブジェクトはそれらのポインタが全く同じである場合に同じ(eq?)だと判断される。

readerは伝統的にobarray(オブジェクト配列)と呼ばれる出会ったすべてのシンボルのひょうを管理する。
readerが文字列に遭遇しシンボルを構築しようとするとき、obarrayをチェックし同じ文字列を以前に見ていないか確認する。
もし初見であれば、文字列を用いて新しいシンボル(新しい文字列に対する型付きポインタ)を構築し、このポインタをobarrayに挿入する。
もしreaderがすでにその文字列を見ていれば、obarrayに格納されているシンボルのポインタを返す。
この文字列を一意なポインタで置き換える処理はシンボルのinterning(抑留)と呼ばれる。

