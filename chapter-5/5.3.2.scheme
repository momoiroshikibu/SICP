5.3.2 無限のメモリの幻想を維持する

実際のコンピュータではいつかは新しいペアを構築するための空き容量を使いきってしまう。
しかし、典型的な演算により生成されるペアの多くは中間結果を保つためだけに使用される。
これらの結果がアクセスされた後には、それらのペアはもう必要ありません。
それらはgarbageです。例えば、以下の演算は
(accumulate + 0 (filter odd? (enumerate-interval 0 n)))
2つのリストを構築します。

enumeration(列挙)と列挙をフィルタリングした結果です。
accumulationが完了した時に、これらのリストはもう必要ありません。
そして割り当てられたメモリは返還要求できます。もし全てのゴミを定期的に回収する準備を行えるのであれば、
そしてもしこれが新しいペアを構築するのとだいたい同じ比率でメモリをリサイクルすることになれば、無限の要領のメモリが存在するという錯覚を維持することができます。
ペアをリサイクルするためには、どの割り当てられたペアが必要でないか(それらの中身がその後の将来の演算に影響しないという意味で)決定する方法を持たねばなりません。
これを達成するために調査する手法はgarbage collectionとして知られています。
ガベージコレクションはLispの逐次実行における任意の時点で、将来の演算に影響をあたえることができるオブジェクトは現状で機械のレジスタ内に存在するポインタによりたどり着くオブジェクトのみであるという観察結果に基づいている。
そのようにアクセスできないどのメモリセルもリサイクルして良い。

stop-and-copyの考えは、メモリを2つに分ける。ワーキングメモリと空きメモリ。
consがペアを構築する時、ワーキングメモリに割り当てる。ワーキングメモリに空きがない時、ワーキングメモリ内の使いみちのあるすべてのペアを探し出し、これらをフリーメモリ内の連続した位置にコピーすることでガベージコレクションを実行します。
(使いみちのあるペアは機械のレジスタからはじめて、全てのcarとcdrのポインタを追跡することにより探しだす)
ゴミはコピーしないため、推定上、新しいペアを割り当てるための利用できる追加の空きメモリが存在するはず。
加えて、ワーキングメモリ内の全てが必要ありません。
その中の使いみちのあるペアはコピーされている。従ってワーキングメモリと空きメモリの役割を交換すれば処理を続けることができる。
新しいペアは新しいワーキングメモリ(空きメモリだったもの)の中に割り当てられる。
これがいっぱいになったなら、使いみちのあるペアを新しい空きメモリ(ワーキングメモリだったもの)の中にコピーできる。


stop-and-copyガベージコレクタの実装
私たちはrootと呼ばれるレジスタが存在し、ある構造体へのポインタを保持し、そのポインタから最終的には全てのアクセス可能なデータを指し示すことができるという前提を行う。
これはガベージコレクションを行う直前に全てのレジスタの中身を事前に割り当てられたリストに格納し、rootにより指し示させることで準備が行える。
私たちはまた現在のワーキングメモリに加えて、使いみちのあるデータをコピーできる空きメモリが存在すると前提する。
現在のワーキングメモリはベースアドレスがthe-carsとthe-cdrsと呼ばれるレジスタに格納されるベクタから成り立ち、そして空きメモリは同様にnew-carsとnew-cdrsと呼ばれるレジスタに格納される。
ガベージコレクションは現在のワーキングメモリ内の空きセルが枯渇した時に引き起こされる。
それはつまり、cons命令がfreeポインタをメモリベクタの終端を超えてインクリメントしようとした時。
ガベージコレクションの処理が完了した時、rootポインタは新しいメモリの中を指し示し、rootからアクセス可能な全てのオブジェクトは新しいメモリに移動されている。
そしてfreeポインタは新しいメモリ内の新しいペアを割り当てられる次の位置を示す。
加えて、ワーキングメモリと新しいメモリの役割が交換される。
新しいペアはfreeにより示される一からはじまる新しいメモリ内の構築され、以前のワーキングメモリは次のガベージコレクションに対する新しいメモリとして使用可能となる。

ガベージコレクション処理の状態は2つのポインタを管理することによりコントロールされている。freeとscanです。
これらは新しいメモリの開始位置を指し示すように初期化される。アルゴリズムはrootにより指し示されるペアの新しいメモリの開始位置への再配置から開始される。
ペアはコピーされ、rootポインタは新しい位置を指すように調整される。
そしてfreeポインタがインクリメントされる。合わせて、ペアの古い位置はその中身が移動されたことを示すマークがツケられる。
このマーキングは次のように行われる。
carの位置にはこれが既に移動されたオブジェクトであることを示す特別なタグを置く。
(このようなオブジェクトは伝統的にbroken heartと呼ばれる)
cdrの位置にはforwarding address(転送先)を置く。
これはオブジェクトの移動先の位置を指し示す。
rootの再配置の後に、ガベージコレクタは基本となるサイクルに入る。
アルゴリズムの各ステップにおいて、scanポインタ(初期値として再配置後のrootを指す)は新しいメモリに移動されたがそのcarとcdrのポインタが依然として古いメモリ内のオブジェクトを参照しているペアを指す。
これらのオブジェクトはそれぞれが再配置され、scanポインタはインクリメントされる。
オブジェクト(例えば操作しているペアのcarポインタにより指されたオブジェクト)を再配置するためにはそのオブジェクトが既に移動されていないかを(そのオブジェクトのcarのいち内にbroken-heartタグが存在することにより示されていないか)確認する。
もしオブジェクトがまだ移動されていなければ、それをfreeにより示される位置にコピーし、freeを更新し、オブジェクトの古い位置にbroken-heartを設定し、そのオブジェクトへのポインタを(この例では、操作しているペアのcarポインタを)更新し、新しい位置を指すようにする。
もしオブジェクトがすでに移動されている場合には、(broken-heartのcdrの位置に見つかる)その移動先は操作中のペアのポインタに置き換えられる。
最終的には、scanポインタがfreeポインタを追い越す時点まで、全てのアクセス可能なオブジェクトは移動され、精査される。
そして処理は停止する。

