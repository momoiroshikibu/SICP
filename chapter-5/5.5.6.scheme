5.5.6 レキシカルアドレッシング

コンパイラにより実行される最も一般的な最適化のひとつは変数検索の最適化。
ここまで実装したコンパイラは評価機のlook-up-variable-value命令を用いるコードを生成する。
これは実行環境を通してフレームごとに取り組みながら、変数を現在束縛されているすべての変数と比較することで変数の検索を行う。
この検索はフレームが深く入れ子になったり、変数の数が多い場合には高コストになり得る。

(let ((x 3) (y 4))
  (lambda (a b c d e)
    (let ((y (* a b x)) (z (+ c d x)))
      (* x y z))))

let式はlambdaの組み合わせのための単なる構文糖なので、以下と等価。
((lambda (x y)
   (lambda (a b c d e)
     ((lambda (y z) (* x y z))
      (* a b x) (+ (c d x)))))
 3
 4)

lookup-variable-valueがxを検索するたびに、シンボルxはy、またはzにeq?でないことを(最初のフレームで)確認しなければならない。
また(2つ目のフレームにて)a b c d eについても同様に必要。
差し当たり、私達のプログラムはdefineを使用しないと仮定する。
つまり変数はlambdaの使用にのみ束縛される。
私達の言語はレキシカルスコープであるため、任意の式のための実行時環境は式が現れるプログラムのレキシカルな(語彙的な)構造を並列化する構造を持つ。
従って、コンパイラは上の式を分析した時に、手続きが適用されるたびに(* x y z)内の変数xが現在のフレームから2つ外のフレームの最初の変数として見つかることを知ることができる。
私たちは新しい種類の変数検索命令、lexical-address-lookupを発明することにより、この事実を利用することができる。
この命令は引数として環境と2つの数値から生るlexical addressを取る。
2つの数値は、いくつのフレームを見送るかを指定するframe numberとそのフレーム内でいくつの変数を見送るかを指定するdisplacement numberです。
lexical-address-lookupは現在のフレームに対して相対的なレキシカルアドレスに格納された変数の値を生成する。
もし私達の機械にlexical-address-lookup命令を追加したなら、コンパイラに対してlookup-variable-valueではなく、この命令を使用して変数を参照するコードを生成させることができる。
同様に、コンパイルされたコードはset-variable-value!の代わりに新しいlexical-address-set!命令を使用することができる。
